package main

import (
	"fmt"
	"math"
	"strconv"
)

var dist189table = map[float64]float64{
	0:  0.00169,
	1:  0.00169,
	2:  0.00169,
	3:  0.00170,
	4:  0.00170,
	5:  0.00170,
	6:  0.00171,
	7:  0.00171,
	8:  0.00171,
	9:  0.00172,
	10: 0.00172,
	11: 0.00173,
	12: 0.00174,
	13: 0.00174,
	14: 0.00175,
	15: 0.00176,
	16: 0.00177,
	17: 0.00178,
	18: 0.00179,
	19: 0.00180,
	20: 0.00181,
	21: 0.00182,
	22: 0.00183,
	23: 0.00184,
	24: 0.00186,
	25: 0.00187,
	26: 0.00189,
	27: 0.00191,
	28: 0.00192,
	29: 0.00194,
	30: 0.00196,
	31: 0.00198,
	32: 0.00200,
	33: 0.00202,
	34: 0.00205,
	35: 0.00207,
	36: 0.00210,
	37: 0.00213,
	38: 0.00215,
	39: 0.00218,
	40: 0.00222,
	41: 0.00225,
	42: 0.00228,
	43: 0.00232,
	44: 0.00236,
	45: 0.00240,
	46: 0.00244,
	47: 0.00249,
	48: 0.00254,
	49: 0.00259,
	50: 0.00264,
	51: 0.00270,
	52: 0.00276,
	53: 0.00282,
	54: 0.00289,
	55: 0.00296,
	56: 0.00304,
	57: 0.00312,
	58: 0.00320,
	59: 0.00330,
	60: 0.00340,
	61: 0.00350,
	62: 0.00362,
	63: 0.00374,
	64: 0.00387,
	65: 0.00402,
	66: 0.00417,
	67: 0.00435,
	68: 0.00453,
	69: 0.00474,
	70: 0.00496,
	71: 0.00521,
	72: 0.00549,
	73: 0.00581,
}

// dist189 возвращает смещение в градусах на 189 метров для данных координат
func (g *Gps) dist189() (north, south, east float64) {
	south = dist189table[0]
	north = 2 * south
	east = dist189table[g.par]
	return
	/*
		вдоль мередиана смешение в градусах постоянно
		вдоль параллели - изменяется в зависимости от широты
		мне нужно вычислить точки А и С от точки I
		т.е. произвести смещение вдоль мередианов и парралелей
		и нужно знать на сколько градусов смещаться для данной широты
		(при движении вдоль параллели, т.е. когда изменяю долготу)
		l = le * math.cos(lat)
		le = // длина дуги на экваторе (1" = 31 метр)
		111321 м в 1 градусе на экваторе (при движении вдоль параллели)
		это 189 раз по 589 метров
		это значит 0.0052910052910053 градусов = 589 метров
		это то число, на которое для точки на экваторе нужно увеличивать или уменьшать
		исходную долготу, чтобы получить долготу точек А и С
		по таблице на широте 57 в 1 градусе 60773 метров
		т.е. 60773/589 = 103,1799660441426 раз, т.е. 0,0096918101296861, т.е. примероно 0,01
		поэтому мне нужно было умножать на 2, чтобы сделать сектор квадратным
		по формуле: 0.0052910052910053 / cos(57) = 0.0052910052910053 / 0,54463903501502708222408369208157 = 0,0097146917499481307802048696476 ~ 0.01

		Уменьшаем dist
		189 метров влево, вправо, вниз
		378 (189*2) метров вверх
		т.е. equator189 0.001697792869269949, eq378 0.00338
	*/

	/*
		Шаг сектора:
		вариант 1: 0.005 на экваторе будут квадратные в этом случае
		вариант 2: 0.01
		вариант 3: 0.001 секторов будет больше (т.е. подписок тоже), но ближе к границе выступать квадраты будут - (1000*180)^2 = 32.400.000.000 секторов будет - не подходит,
		т.к. даже на экваторе будет (5+5)*(5+5) = 100 подписок
		Значит, вариант 2
		Поскольку секторы больше дистанции смещения при поиске А и С, то количество секторов может быть меньше 4 - протестируем на разных точках земной поверхности
	*/

	/*
		Северный и южный полюсы
		Все кто выше 89 и ниже -89 - в одном секторе (не беда, там всего может 1000 человек)
	*/

	/*
		Гринвич - нулевой меридиан
		?
	*/

	// случай когда параллель -> 90 или -90 (будет очень много секторов)
	// return 3.14
}

// Gps координаты
type Gps struct {
	lat float64
	lon float64
	par float64 // parallel
}

func newGps(lat, lon float64) (gps *Gps, err error) {
	var par float64
	// if lat > 180 || lat < -180 || lon > 90 || lon < -90 {
	// if lat > 179.9 || lat < -179.9 || lon > 89 || lon < -89 {
	if lat > 179.9 || lat < -179.9 || (lat > -0.1 && lat < 0.1) || lon > 72 || lon < -72 || (lon > -0.1 && lon < 0.1) {
		/**
		самые северные крупные поселения
		10000 чел - Хаммерфест (Норвегия) lat 70.6
		4000 чел. - Барроу (Аляска) lat 71.5
		65000 чел - Тромсё (Норвегия) lat 69.6
		180000 ч. - Норильск (Россия) lat 69.3
		самый южный
		60000 ч.  - Ушуая (Аргентина) lat -54.8
		*/
		err = fmt.Errorf("coordinates out of range")
	} else {
		par = math.Abs(math.Floor(lat))
	}
	// TODO: для крайних случаев делаем обработку (180, -180, 90, -90, 0)
	// для большого превышения ? возвращаем ошибку, но крайние случаи - норма, обрабатываем
	return &Gps{lat, lon, par}, err
}

// Получить числовые части названия сектора точки
// секторы делятся по 0.01 т.е. 57.01 57.02 ..
// сектор определяется верхней правой точкой
// т.е. 57.633895, 39.834598 -> 5764, 3984
func (g *Gps) sectornums() (lat int, lon int) {
	lat = int(math.Ceil(g.lat * 100))
	lon = int(math.Ceil(g.lon * 100))
	return
}

// Вычислить все секторы
// [0] member sector
func (g *Gps) calculate() (membersec string, allsectors map[string]bool, err error) {
	// main sector isec (Iam)
	ila, ilo := g.sectornums()
	membersec = strconv.Itoa(ila) + ":" + strconv.Itoa(ilo)
	// isec := strconv.Itoa(ila) + ":" + strconv.Itoa(ilo)

	// нужно вычислить точки A и C
	north, south, east := g.dist189()
	a, err := newGps(g.lat-south, g.lon-east)
	if err != nil {
		err = fmt.Errorf("failed to create point A")
	}
	c, err := newGps(g.lat+north, g.lon+east)
	if err != nil {
		err = fmt.Errorf("failed to create point C")
	}
	allsectors = screen(a, c)
	return
}

// screen calculates all sectors for A and C screen points
func screen(a *Gps, c *Gps) (sectors map[string]bool) {
	ala, alo := a.sectornums()
	cla, clo := c.sectornums()
	cap := (cla - ala + 1) * (clo - alo + 1) // TODO test this with different placies & 180
	sectors = make(map[string]bool, cap)
	var n string
	for i := ala; i <= cla; i++ {
		for j := alo; j <= clo; j++ {
			n = strconv.Itoa(i) + ":" + strconv.Itoa(j)
			sectors[n] = true
		}
	}
	return
}
